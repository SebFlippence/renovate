module.exports = {
  detectVulnerabilityAlerts,
};

async function detectVulnerabilityAlerts(input) {
  if (!(input && input.vulnerabilityAlerts)) {
    return input;
  }
  if (input.vulnerabilityAlerts.enabled === false) {
    logger.debug('Vulnerability alerts are disabled');
    return input;
  }
  const alerts = await platform.getVulnerabilityAlerts();
  if (!alerts.length) {
    logger.debug('No vulnerability alerts found');
    if (input.vulnerabilityAlertsOnly) {
      throw new Error('no-vulnerability-alerts');
    }
    return input;
  }
  const config = { ...input };
  const alertPackageRules = alerts
    .filter(alert => !alert.dismissReason)
    .filter(
      alert =>
        alert.securityVulnerability &&
        alert.securityVulnerability.firstPatchedVersion &&
        alert.securityVulnerability.package
    )
    .map(alert => {
      const rule = {};
      const languageMapping = {
        MAVEN: ['java'],
        NPM: ['js'],
        NUGET: ['dotnet'],
        PIP: ['python'],
        RUBYGEMS: ['ruby'],
      };
      const languages =
        languageMapping[alert.securityVulnerability.package.ecosystem];
      if (languages) {
        rule.languages = languages;
      }
      rule.packageNames = [alert.securityVulnerability.package.name];
      // Raise only for where the currentVersion is vulnerable
      rule.matchCurrentVersion = `< ${
        alert.securityVulnerability.firstPatchedVersion.identifier
      }`;
      // Don't propose upgrades to any versions that are still vulnerable
      rule.allowedVersions = `>= ${
        alert.securityVulnerability.firstPatchedVersion.identifier
      }`;
      rule.force = {
        ...config.vulnerabilityAlerts,
        vulnerabilityAlert: true,
      };
      return rule;
    })
    .filter(Boolean);
  config.packageRules = (config.packageRules || []).concat(alertPackageRules);
  return config;
}
